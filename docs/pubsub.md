# 消息推送與訂閱： `LISTEN` / `NOTIFY`

## `1` . 基礎方案： `LISTEN` / `NOTIFY`
`PostgreSQL` 自帶了輕量的消息機制，就像一個簡單的廣播電台。

### 核心原理
- **發送**：用 `NOTIFY channel, 'payload'` 發送一條消息。
- **接收**：訂閱者用 `LISTEN channel` 監聽消息。
- **原子性**：消息可以在交易內發送，只有交易**成功提交**，消息才會發出去。這保證了「存數據」和「發通知」的一致性。

### 信號模式 ( 最佳實踐 )
不要在 `NOTIFY` 的 `payload` 裡塞太多數據 ( 限制為 `8` `KB` )。
**推薦做法**：只發一條消息告訴訂閱者「數據更新了， `ID` 是 `XXX` 」。訂閱者收到信號後，回表查詢完整數據。

### 局限性
- **不持久**：如果訂閱者斷線，它會錯過斷線期間的所有消息。
- **廣播模式**：所有訂閱同個通道的人都會收到同樣的消息 ( 每個人都得處理一遍 )。

---

## `2` . 進階方案： `PGMQ` ( 可靠隊列 )
如果你需要**消息不丟失**，或者需要**多個消費者搶著幹活** ( 每條消息只被處理一次 )，請使用 `[PGMQ](https://github.com/tembo-io/pgmq)` 。

### 為什麼選 `PGMQ` ？
| 特點 | `LISTEN/NOTIFY` | `PGMQ` |
| :--- | :--- | :--- |
| **持久化** | ❌ 丟了就丟了 | ✅ 消息存在表裡，不會丟 |
| **競爭消費** | ❌ 所有人都會收到 | ✅ 誰搶到誰幹，單次處理 |
| **重試機制** | ❌ 無 | ✅ 處理失敗自動重新可見 |
| **可見性逾時** | ❌ 無 | ✅ 消費者領走後暫不可見，逾時未確認會重回隊列 |

### 快速上手 `PGMQ`
```sql
-- 發送消息
SELECT pgmq.send('my_queue', '{"user_id": 123}');

-- 讀取消息 ( 30 秒內對別人不可見 )
SELECT * FROM pgmq.read('my_queue', 30, 1);

-- 處理完後刪除
SELECT pgmq.delete('my_queue', msg_id);
```

### 什麼時候該「升級」到 `PGMQ` ?
- 業務邏輯要求「消息絕對不能丟」。
- 需要橫向擴展 `Worker` 數量來處理大量任務。
- 處理邏輯比較重，需要重試機制。

---

## `3` . 性能提醒
無論是 `NOTIFY` 還是 `PGMQ` ，它們本質上都在消耗資料庫資源。
- **`LISTEN/NOTIFY`** 會佔用長連接。
- **`PGMQ`** 本質是頻繁對表進行讀寫刪，會產生大量日誌和「死行」。

**建議**：
1. 消息量在 `1,000` / `s` 以下時， `Postgres` 綽綽有餘。
2. 如果消息量達到了萬級/秒，或者資料庫因為處理隊列壓力太大，建議移步 `Redis Streams` 或 `Kafka` 。
