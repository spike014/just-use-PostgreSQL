# 限流：单条 upsert

## 概览
通过 `INSERT ... ON CONFLICT DO UPDATE` 原子更新计数与窗口起点，实现并发安全的计数限流。

关联实现：`sql/001_init.sql`、`src/rate-limit.ts`。

## 原理与为什么可行
- `ON CONFLICT` 在数据库层完成“存在则更新”的逻辑，避免并发竞态。
- `window_start` 与 `request_count` 在单条 SQL 内更新，保证一致性。
- 数据库存储是唯一真相源，避免跨系统同步问题。

## 与普通表的区别
- 普通表更新通常需要“先查后改”，容易出现并发竞态。
- 限流表按 user_id 维持单行计数，读写集中，需关注热点。

## 推荐维护策略
- **清理陈旧数据**：定期删除长期未更新的用户行。
- **热点分散**：高并发场景可按维度拆分 key（如 user_id + endpoint）。
- **指标监控**：关注行锁等待与更新延迟。

## 监控与告警建议
- **锁竞争**：监控 `pg_locks` 中 rate_limits 相关锁等待。
- **热点 key**：统计单 key 更新频率，识别热点用户/接口。
- **延迟与失败率**：关注限流判断的 P95/P99 延迟与错误率。
- **行增长**：监控表行数，避免长期积累。

## 参数与策略建议
- **窗口大小**：固定窗口简单可靠；高精度可考虑滑动窗口（实现更复杂）。
- **key 粒度**：按 user_id / token / endpoint 组合，平衡热点与精度。
- **阈值设置**：根据业务峰值与容错设置 maxRequests。
- **清理周期**：按最大全窗口的 2–5 倍周期清理历史数据。

## 压测与验收建议
- **单 key 冲击**：高并发请求同一 key，验证锁竞争与准确性。
- **多 key 并发**：模拟多用户并发，确认整体吞吐。
- **窗口边界**：验证窗口重置时计数行为是否符合预期。

## 适用场景
- 单机或中等流量 API 的用户/令牌限流。
- 需要强一致限流（同事务内记录请求）的场景。

## 缺点 / 注意点
- **热点行竞争**：同一 key 高并发更新会出现锁竞争。
- **高吞吐受限**：极高 QPS 下可能不如 Redis 计数器。
- **窗口精度有限**：示例为固定窗口计数，不是滑动窗口。
