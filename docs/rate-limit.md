# 介面限流：單條 `Upsert`

## 核心原理
利用 `PostgreSQL` 的 `INSERT ... ON CONFLICT DO UPDATE` ( 俗稱 `Upsert` ) 來實現原子計數。

- **單條 `SQL` 完成**：
  在一條 `SQL` 裡完成：「如果沒有這條記錄就創建，如果有且在時間窗口內就計數 `+1` ，如果時間窗口過了就重置」。
- **併發安全**：
  資料庫會保證這行數據的更新是原子的。你不需要像在 `Redis` 裡那樣寫複雜的 `Lua` 腳本，也不用擔心「兩個請求同時來，結果只算了一次」的問題。

## 維護建議
1. **索引**：限流通常按 `key` ( 比如 `IP` 或用戶 `ID` ) 查，主鍵或唯一索引是必須的。
2. **清理**：限流記錄通常只要過了一段時間就沒用了。建議定期刪掉那些更新時間是很久以前的數據。

## 局限性
- **鎖競爭**：如果同一個 `Key` ( 比如某個超級熱門的 `API` ) 每秒被請求幾千次，資料庫這一行可能會成為性能瓶頸 ( 因為有很多連接在排隊等這行數據的鎖 ) 。
- **滑動窗口**：本範例提供的是「固定窗口」演算法 ( 比如每分鐘 `100` 次 ) 。如果你需要極高精度的「滑動窗口」，程式碼會變得複雜，性能也會下降。

## 總結
對於大多數 `API` 的防刷和基礎限流， `Postgres` 的 `Upsert` 方案既簡單又可靠，還沒增加任何系統複雜性。
