# 快取實現： `UNLOGGED` 表 + `TTL`

## 核心原理
我們使用 `PostgreSQL` 的 `UNLOGGED` 表來存儲快取。
- **快**： `UNLOGGED` 表不記錄 `WAL` 日誌，寫入速度接近 `Redis` 。
- **自動過期 ( `TTL` )**：通過 `expires_at` 欄位標記過期時間。查詢時只查 `expires_at > NOW()` 的數據。
- **注意**：由於不記日誌，資料庫崩潰重啟後， `UNLOGGED` 表的數據會被清空。這非常符合「快取」的定義。

## 維護建議 ( 核心 )
快取表需要定期清理過期數據，否則會無限膨脹。

### `1` . 推薦方案：使用 `pg_cron` 自動清理
建議每 `10` 分鐘清理一次並回收空間：

```sql
SELECT cron.schedule('cache-cleanup', '*/10 * * * *', $$
  DELETE FROM cache WHERE expires_at < NOW();
  VACUUM cache;
$$);
```

### `2` . 為什麼需要手動 `VACUUM` ？
雖然 `Postgres` 有 `autovacuum` ，但它是等垃圾數據達到一定比例 ( 預設 `20` % ) 才觸發。對於快取這種頻繁寫、頻繁刪的表，手動定期 `VACUUM` 能更及時地回收磁碟空間，防止表「虛胖」。

## 什麼時候用？
- **推薦**：中小規模系統、需要在一個交易裡「存業務數據 + 刪快取」的場景。
- **不推薦**：超大规模高併發 ( `100,000` + `QPS` )、或者快取數據絕對不能因為資料庫重啟而丟失的情況。

## 監控指標
- **表大小**：關注 `cache` 表佔了多少磁碟空間。
- **死行數**：如果 `n_dead_tup` 很高，說明清理不及時。
- **延遲**：在應用層記錄快取讀寫的 `P99` 延遲，通常應在 `1` `ms` 左右。
