# 队列：SKIP LOCKED

## 概览
使用 `FOR UPDATE SKIP LOCKED` 实现多 worker 并发领取任务，避免重复处理。

关联实现：`sql/001_init.sql`、`src/queue.ts`。

## 原理与为什么可行
- `SELECT ... FOR UPDATE` 对领取的行加行级锁。
- `SKIP LOCKED` 让其他 worker 跳过已锁行，减少等待与争抢。
- 领取 + attempts 自增在同一 SQL 语句内完成，保证原子性。

## 与普通表的区别
- 普通表读写不会加“任务领取语义”的锁。
- 队列表需要“只被一个 worker 领取”，必须依赖锁与排序。
- 任务执行完成后通常删除或归档，以控制表大小。

## 推荐维护策略
- **索引**：对 `(queue, scheduled_at)` 建索引（已提供）。
- **清理策略**：完成任务删除或归档；失败任务进入死信表。
- **超时回收**：可增加 `locked_at` / `visibility_timeout` 字段，用于回收长时间未完成任务。
- **批量领取**：高吞吐场景可一次领取多条任务。
- **Vacuum**：频繁 delete 会造成膨胀，需定期 vacuum。

## 监控与告警建议
- **队列长度**：按队列统计待处理数量、失败数量与重试次数。
- **延迟**：监控任务从 `scheduled_at` 到处理的延迟分布。
- **锁等待**：关注 `pg_locks` 中与 jobs 表相关的锁等待。
- **表膨胀**：监控 dead tuples 和表大小增长。

## 参数与策略建议
- **max_attempts**：根据业务容错设置（如 3–10 次）。
- **领取批量**：高吞吐场景可按批量领取（如 10–100 条）。
- **超时策略**：为任务增加超时和回收机制，防止“卡住”。
- **归档策略**：对完成任务做冷存档或保留时间上限。

## 压测与验收建议
- **并发领取**：多 worker 并发测试，验证不重复消费。
- **失败重试**：模拟失败任务，确认 attempts 递增与死信逻辑。
- **吞吐上限**：逐步提高 QPS，观察延迟与锁等待情况。

## 适用场景
- 中等吞吐量的后台任务处理。
- 需要事务一致性（领取与业务写入同事务）时。

## 缺点 / 注意点
- **表膨胀**：大量插入与删除会带来 bloat。
- **长事务风险**：worker 长事务会拖慢 vacuum。
- **极端吞吐**：高并发下可能不如 Redis 专用队列。
- **可见性问题**：需要设计超时/重试策略，避免任务永久卡住。
