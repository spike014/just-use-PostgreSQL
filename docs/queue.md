# 任務隊列實現： `SKIP LOCKED`

## 核心原理
我們利用 `PostgreSQL` 的行級鎖來實現一個簡單、併發安全的任務隊列。

- **領取任務**：使用 `SELECT ... FOR UPDATE SKIP LOCKED` 。
  - `FOR UPDATE` ：給這行數據加鎖，確保同一時間只有一個 `Worker` 能領到。
  - `SKIP LOCKED` ：極其重要！它讓 `Worker` 跳過已經被鎖定的行，直接去搶下一行。這樣多個 `Worker` 同時幹活也不會互相阻塞。
- **狀態流轉**：通常在單條 `SQL` 中完成「查詢並標記為處理中」，保證原子性。

## 維護建議
1. **及時清理**：任務處理完後，建議直接 `DELETE` 掉或者移到「歷史表」。如果全堆在 `jobs` 表裡，表會越來越慢。
2. **激進的 `VACUUM`** ：隊列表頻繁插入和刪除，會產生大量「死行」。建議手動或通過 `pg_cron` 頻繁執行 `VACUUM jobs;` 。
3. **監控隊列長度**：老掉牙的建議，但很有用。如果待處理任務一直在增加，說明 `Worker` 數量不夠了。

## `PGMQ` ：更專業的選擇
如果你發現自己正在手動寫「任務逾時回收」、「死信隊列 ( 處理失敗的任務去哪 ) 」等邏輯，說明你應該換成 `[PGMQ](pubsub.md#2-進階方案pgmq-可靠隊列)` 了。

本專案的 `SKIP LOCKED` 只是展示原理。 `PGMQ` 在底層也用了類似的原理，但它把重試、逾時、歸檔等各種髒活累活都幫你做好了。

## 什麼時候用？
- **推薦**：需要交易強一致性 ( 比如：創建訂單的同時，要在同一個交易裡塞一個「發郵件」的任務 ) 。
- **不推薦**：超高頻率的小任務 ( 每秒幾萬個 ) ，這會給資料庫帶來巨大的日誌壓力。
